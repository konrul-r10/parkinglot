import time
import cv2 as cv
from ultralytics import YOLO
import numpy as np
import paho.mqtt.client as mqtt
from PIL import Image, ImageDraw, ImageFont
from datetime import datetime, timedelta
from astral import LocationInfo
from astral.sun import sun
import pytz

# Model tahmini için sayaç ve son tahmin sonucunu saklayan değişkenler
model_inference_counter = 0
prev_results = None

# FPS hesaplama için değişkenler
start_time = time.time()
frame_counter = 0
fps = 0

######################################################Gece-Gündüz##################################################
# Çorlu için konum bilgisi
city = LocationInfo(name="Çorlu", region="Türkiye", timezone="Europe/Istanbul", latitude=41.1591, longitude=27.7981)


######################################################Gece-Gündüz##################################################

def adjust_brightness_contrast(image, alpha=1.2, beta=30):
    """
    Görüntünün kontrastını ve parlaklığını ayarlar.
    :param image: Giriş görüntüsü (BGR formatında)
    :param alpha: Kontrast faktörü (1.0'dan büyükse kontrast artar)
    :param beta: Parlaklık artırma değeri (pozitif değer parlaklığı artırır)
    :return: Ayarlanmış görüntü
    """
    adjusted_image = cv.convertScaleAbs(image, alpha=alpha, beta=beta)
    return adjusted_image




# ROI alan kontrolü:
def is_roi_occupied(mask, roi_points, threshold=0.15):
    roi_mask = np.zeros(mask.shape[:2], dtype=np.uint8)
    cv.fillPoly(roi_mask, [np.array(roi_points)], 255)
    overlap = cv.bitwise_and(mask, mask, mask=roi_mask)
    total_roi = np.sum(roi_mask) / 255
    overlap_area = np.sum(overlap) / 255
    return (overlap_area / total_roi) >= threshold if total_roi != 0 else False


def apply_CLAHE(image):
    lab = cv.cvtColor(image, cv.COLOR_BGR2LAB)  # LAB renk uzayına çevir
    l, a, b = cv.split(lab)  # Luminance (parlaklık) kanalını ayır

    # Global histogram eşitleme uygulaması (opsiyonel)
    l = cv.equalizeHist(l)

    clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(4, 4))
    l = clahe.apply(l)  # CLAHE uygula

    lab = cv.merge((l, a, b))  # Kanalları tekrar birleştir
    enhanced_img = cv.cvtColor(lab, cv.COLOR_LAB2BGR)  # Tekrar BGR formatına çevir
    return enhanced_img


# Keskinleştirme filtresi
def apply_sharpen(image):
    kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])
    return cv.filter2D(image, -1, kernel)
    # return sharpened_img


def put_text_with_border(image, text, position, font, font_scale, color, thickness=2, border_thickness=3):
    # Kenarlık için yazıyı 4 yönde çizin
    for dx, dy in [(-border_thickness, 0), (border_thickness, 0), (0, -border_thickness), (0, border_thickness)]:
        cv.putText(image, text, (position[0] + dx, position[1] + dy), font, font_scale, (0, 0, 0), thickness,
                   cv.LINE_AA)

    # Gerçek yazıyı çizin
    cv.putText(image, text, position, font, font_scale, color, thickness, cv.LINE_AA)


def adjust_gamma(image, gamma=1.5):
    """
    Gamma düzeltmesi uygular.
    :param image: Giriş görüntüsü (BGR formatında)
    :param gamma: Gamma değeri (1.0'dan küçükse karartır, büyükse aydınlatır)
    :return: Gamma düzeltilmiş görüntü
    """
    inv_gamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** inv_gamma) * 255 for i in np.arange(0, 256)]).astype("uint8")
    return cv.LUT(image, table)


# Türkçe karakter desteği için font dosyasını yükleyin
font_path = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"  # Türkçe destekleyen bir .ttf dosyası, örn: "arial.ttf"
font = ImageFont.truetype(font_path, 10)

# YOLOv8 segmentasyon modeli yükleniyor
model = YOLO('yolov8m-seg.pt')  # ///yolov8n-seg.pt yerine
model.overrides['verbose'] = True  # Tüm logları devre dışı bırakır
cap = cv.VideoCapture('http://2xxxxxxxx10101/?action=stream')  # 'http://xxxxxxxxxxx:10101/?action=stream'

# MQTT Ayarları
MQTT_BROKER = "192.168.1.xxx"
MQTT_PORT = 1883
MQTT_TOPIC_SLOT1 = "slots/slot1/status"
MQTT_TOPIC_SLOT2 = "slots/slot2/status"
MQTT_TOPIC_SLOT3 = "slots/slot3/status"
MQTT_TOPIC_SLOT4 = "slots/slot4/status"
MQTT_TOPIC_SLOT5 = "slots/slot5/status"
MQTT_TOPIC_SLOT6 = "slots/slot6/status"


# Geri çağırma fonksiyonları
def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("MQTT Bağlantısı başarılı.")
    else:
        print(f"MQTT Bağlantı hatası: {rc}")


def on_publish(client, userdata, mid):
    pass


# MQTT İstemcisi Başlatma
mqtt_client = mqtt.Client(protocol=mqtt.MQTTv311)  # Protokol versiyonunu belirtin
mqtt_client.on_connect = on_connect
mqtt_client.on_publish = on_publish
mqtt_client.connect(MQTT_BROKER, MQTT_PORT, keepalive=60)
mqtt_client.loop_start()

# LWT Mesajı Ayarla
mqtt_client.will_set("parking/status/occupied", "unknown", qos=1, retain=True)
mqtt_client.will_set("parking/status/empty", "unknown", qos=1, retain=True)
mqtt_client.will_set("parking/status/empty_slots", "unknown", qos=1, retain=True)

# Türkçe etiketler (Örnek)
turkish_labels = {
    "person": "insan",
    "car": "araba",
    "dog": "köpek",
    "cat": "kedi",
    "bicycle": "bisiklet",
    # Daha fazla sınıf eklenebilir
}
# ROI saatleri
roi1_status_time = None
roi1_status_hour = None
roi2_status_time = None
roi2_status_hour = None
roi3_status_time = None
roi3_status_hour = None
roi4_status_time = None
roi4_status_hour = None
roi5_status_time = None
roi5_status_hour = None
roi6_status_time = None
roi6_status_hour = None

# ROI Koordinatları
roi1_points = [(13, 123), (48, 120), (65, 155), (20, 171)]  # sol üst--->sağ üst--->sağ alt--->sol alt
roi2_points = [(52, 130), (89, 120), (113, 155), (72, 170)]  # sol üst--->sağ üst--->sağ alt--->sol alt
roi3_points = [(95, 130), (126, 120), (159, 155), (123, 168)]  # sol üst--->sağ üst--->sağ alt--->sol alt
roi4_points = [(136, 130), (165, 120), (205, 155), (170, 168)]  # sol üst--->sağ üst--->sağ alt--->sol alt
roi5_points = [(174, 130), (207, 120), (252, 156), (221, 170)]  # sol üst--->sağ üst--->sağ alt--->sol alt
roi6_points = [(215, 130), (243, 120), (291, 152), (268, 168)]  # sol üst--->sağ üst--->sağ alt--->sol alt

# ROI için sol alt köşe koordinatları
roi1_bottom_left = (roi1_points[3][0] - 10, roi1_points[3][1] + 10)
roi2_bottom_left = (roi2_points[3][0] - 10, roi2_points[3][1] + 10)
roi3_bottom_left = (roi3_points[3][0] - 10, roi3_points[3][1] + 10)
roi4_bottom_left = (roi4_points[3][0] - 10, roi4_points[3][1] + 10)
roi5_bottom_left = (roi5_points[3][0] - 10, roi5_points[3][1] + 10)
roi6_bottom_left = (roi6_points[3][0] - 10, roi6_points[3][1] + 10)

# Özel piksel kontrol koordinatları
specific_pixel_roi1 = (34, 128)
specific_pixel_roi2 = (75, 126)
specific_pixel_roi3 = (121, 133)
specific_pixel_roi4 = (165, 133)
specific_pixel_roi5 = (209, 132)
specific_pixel_roi6 = (257, 132)

# ROI'nin önceki durumlarını saklayan değişkenler
roi1_prev_status = None
roi2_prev_status = None
roi3_prev_status = None
roi4_prev_status = None
roi5_prev_status = None
roi6_prev_status = None

# Ek olarak her ROI için ardışık kare sayacı ekleyin:
roi1_stable_count = 0
roi2_stable_count = 0
roi3_stable_count = 0
roi4_stable_count = 0
roi5_stable_count = 0
roi6_stable_count = 0

def apply_transparent_color(image, points, color, opacity):
    overlay = image.copy()
    points = np.array(points, dtype=np.int32)
    cv.fillPoly(overlay, [points], color)
    cv.addWeighted(overlay, opacity, image, 1 - opacity, 0, image)


# ROI çizgilerini şeffaf çizmek için bir fonksiyon
def draw_transparent_lines(image, points, color, opacity):
    overlay = image.copy()  # Görüntü kopyası
    points = np.array(points, dtype=np.int32)
    cv.polylines(overlay, [points], isClosed=True, color=color, thickness=1)  # Çizgileri overlay'e çiz
    cv.addWeighted(overlay, opacity, image, 1 - opacity, 0, image)  # Overlay'i ana görüntüye ekle


# Önceki durumları saklamak için değişkenler
prev_occupied_count = None
prev_empty_count = None
prev_empty_slots = []

# Kamera yeniden bağlanma fonksiyonu
retry_count = 0
max_retries = 20


def reconnect_camera():
    global cap, retry_count
    cap.release()  # Mevcut kamerayı serbest bırak
    print(f"Kamera bağlantısı kesildi, {retry_count}/{max_retries} deneme yapılıyor... 3 dakika bekleniyor.")
    time.sleep(180)  # 3 dakika bekle
    cap = cv.VideoCapture('http://xxxxxxxxxxxx:10101/?action=stream')  # Kamerayı yeniden bağla
    if cap.isOpened():  # Kamera başarılı bir şekilde bağlanırsa
        print(f"Kamera bağlantısı {retry_count}. denemede başarıyla kuruldu!")
        retry_count = 0  # Deneme sayısını sıfırla
        return True
    if retry_count >= max_retries:
        print(f"Kamera bağlantısı {max_retries} deneme sonrası başarısız oldu. Çıkılıyor...")
        return False
    return True


try:
    while True:  # Döngü sürekli çalışmalı
        # Kamera bağlantısını kontrol et
        if not cap.isOpened():
            if not reconnect_camera():
                break  # Maksimum deneme sayısına ulaşıldıysa çıkış yap

        ret, image = cap.read()
        if not ret or image is None:
            print('Görüntü alınamadı, kamera yeniden bağlanıyor...')
            if not reconnect_camera():
                break  # Maksimum deneme sayısına ulaşıldıysa çıkış yap
            continue  # Yeniden bağlanma sonrası döngüye devam et
            print(f"Kamera bağlantısı {retry_count} defa yeniden denendi ve bağlandı  ...")

        # CLAHE ile kontrast iyileştirme uygula
        image = apply_CLAHE(image)
        # Keskinleştirme filtresi uygula
        image = apply_sharpen(image)
        # Ek parlaklık ve kontrast ayarı uygulama
        image = adjust_brightness_contrast(image, alpha=1.2, beta=30)

        # Doluluk ve boş sayısını sıfırla
        occupied_count = 0
        empty_count = 0
        empty_slots = []



        # Model tahmini (confidence %35 olarak ayarlanır)
        results = model(image, conf=0.35, stream=True, iou=0.35, agnostic_nms=True, max_det=10,
                        verbose=False)  # ----------------> Model Tahmini
        if not results:
            print("nesne yok, atla...")
            continue

        # Görüntü kopyası al
        segments = image.copy()

        # Belirli bir koordinatın BGR değerlerini kontrol et --------> Gece kontrol yazısı
        coordinate = (35, 15)  # x=35, y=15
        b, g, r = segments[coordinate[1], coordinate[0]]  # OpenCV'de sıra (y, x)

        # Tespit edilen nesnelerin maskelerini ve etiketlerini çiz
        roi1_occupied = False  # roi1'de nesne olup olmadığını kontrol etmek için bayrak
        roi2_occupied = False  # roi2'de nesne olup olmadığını kontrol etmek için bayrak
        roi3_occupied = False  # roi3'de nesne olup olmadığını kontrol etmek için bayrak
        roi4_occupied = False  # roi4'de nesne olup olmadığını kontrol etmek için bayrak
        roi5_occupied = False  # roi5'de nesne olup olmadığını kontrol etmek için bayrak
        roi6_occupied = False  # roi6'de nesne olup olmadığını kontrol etmek için bayrak

        specific_pixel_occupied_roi1 = False  # roi1 için belirtilen pikselde nesne olup olmadığını kontrol için bayrak
        specific_pixel_occupied_roi2 = False  # roi2 için belirtilen pikselde nesne olup olmadığını kontrol için bayrak
        specific_pixel_occupied_roi3 = False  # roi3 için belirtilen pikselde nesne olup olmadığını kontrol için bayrak
        specific_pixel_occupied_roi4 = False  # roi4 için belirtilen pikselde nesne olup olmadığını kontrol için bayrak
        specific_pixel_occupied_roi5 = False  # roi5 için belirtilen pikselde nesne olup olmadığını kontrol için bayrak
        specific_pixel_occupied_roi6 = False  # roi6 için belirtilen pikselde nesne olup olmadığını kontrol için bayrak

        allowed_classes = ["car", "truck", "bus", "person", "cat", "dog", "motorcycle", "bicycle"]

        for r in results:
            if r.masks is not None:  # 'masks' özelliği None değilse işleme devam et
                try:
                    masks = r.masks.data.cpu().numpy()  # Segmentasyon maskelerini al
                    boxes = r.boxes.xyxy.cpu().numpy()  # Nesne kutularını al
                    classes = r.boxes.cls.cpu().numpy()  # Nesne sınıflarını al
                    confidences = r.boxes.conf.cpu().numpy()  # Confidence değerlerini al
                except AttributeError:
                    print("maske yada kutu yok, atla...")
                    continue

                for i, mask in enumerate(masks):
                    class_index = int(classes[i])
                    class_name = model.names[class_index]  # Sınıf adını al

                    # Sadece belirlenen sınıfları kabul et
                    if class_name not in allowed_classes:
                        continue  # Eğer sınıf izin verilen listede yoksa, bu nesneyi atla

                    # Yalnızca confidence %25 üzerindeyse işleme devam et
                    if confidences[i] < 0.30:
                        continue

                    # Maskeyi görüntü boyutlarına yeniden boyutlandır
                    mask_resized = cv.resize(mask, (segments.shape[1], segments.shape[0]),
                                             interpolation=cv.INTER_NEAREST)
                    mask_resized = (mask_resized > 0.5).astype("uint8")  # Binary hale getir

                    if is_roi_occupied(mask_resized, roi1_points):
                        specific_pixel_occupied_roi1 = True
                    if is_roi_occupied(mask_resized, roi2_points):
                        specific_pixel_occupied_roi2 = True
                    if is_roi_occupied(mask_resized, roi3_points):
                        specific_pixel_occupied_roi3 = True

                    ########################################################################################################################################################################################################################
                    # if mask_resized[specific_pixel_roi4[1], specific_pixel_roi4[0]] == 1:
                    # specific_pixel_occupied_roi4 = True
                    if is_roi_occupied(mask_resized, roi4_points):
                        specific_pixel_occupied_roi4 = True
                    ########################################################################################################################################################################################################################
                    if is_roi_occupied(mask_resized, roi5_points):
                        specific_pixel_occupied_roi5 = True
                    if is_roi_occupied(mask_resized, roi6_points):
                        specific_pixel_occupied_roi6 = True

                    # Maske sınırlarını çiz
                    contours, _ = cv.findContours(mask_resized, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
                    cv.drawContours(segments, contours, -1, (0, 255, 0), 1)  # Sarı renkli sınırlar

                    #                     Şeffaf maske ekle
                    #                    colored_mask = np.zeros_like(segments, dtype=np.uint8)
                    #                    colored_mask[mask_resized == 1] = [0, 0, 255]  # Yeşil renk
                    #                    segments = cv.addWeighted(segments, 0.98, colored_mask, 0.02, 1)  # Şeffaflık

                    # Belirli bir pikselde nesne kontrolü (ROI 1)
                    if mask_resized[specific_pixel_roi1[1], specific_pixel_roi1[0]] == 1:
                        specific_pixel_occupied_roi1 = True

                    # Belirli bir pikselde nesne kontrolü (ROI 2)
                    if mask_resized[specific_pixel_roi2[1], specific_pixel_roi2[0]] == 1:
                        specific_pixel_occupied_roi2 = True

                    # Belirli bir pikselde nesne kontrolü (ROI 3)
                    if mask_resized[specific_pixel_roi3[1], specific_pixel_roi3[0]] == 1:
                        specific_pixel_occupied_roi3 = True

                    # Belirli bir pikselde nesne kontrolü (ROI 4)
                    if mask_resized[specific_pixel_roi4[1], specific_pixel_roi4[0]] == 1:
                        specific_pixel_occupied_roi4 = True

                    # Belirli bir pikselde nesne kontrolü (ROI 5)
                    if mask_resized[specific_pixel_roi5[1], specific_pixel_roi5[0]] == 1:
                        specific_pixel_occupied_roi5 = True

                    # Belirli bir pikselde nesne kontrolü (ROI 6)
                    if mask_resized[specific_pixel_roi6[1], specific_pixel_roi6[0]] == 1:
                        specific_pixel_occupied_roi6 = True

        #                     Etiket ve confidence değerini kutunun üstüne ekle
        #                    x1, y1, x2, y2 = map(int, boxes[i])  # Kutunun koordinatları
        #                    original_label = model.names[int(classes[i])]  # Orijinal sınıf adı
        #                    label = turkish_labels.get(original_label, original_label)  # Türkçe karşılığını al
        #                    confidence_text = f"{label} ({confidences[i]:.2f})"  # Etiket ve confidence
        #                    cv.putText(segments, confidence_text, (x1, y1 - 3), cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)

        # roi1 çiz (şeffaf çizgi)
        draw_transparent_lines(segments, roi1_points, (0, 255, 255), 0.25)

        # roi2 çiz (şeffaf çizgi)
        draw_transparent_lines(segments, roi2_points, (0, 255, 255), 0.25)

        # roi3 çiz (şeffaf çizgi)
        draw_transparent_lines(segments, roi3_points, (0, 255, 255), 0.25)

        # roi4 çiz (şeffaf çizgi)
        draw_transparent_lines(segments, roi4_points, (0, 255, 255), 0.25)

        # roi5 çiz (şeffaf çizgi)
        draw_transparent_lines(segments, roi5_points, (0, 255, 255), 0.25)

        # roi6 çiz (şeffaf çizgi)
        draw_transparent_lines(segments, roi6_points, (0, 255, 255), 0.25)
        ##################################### FPS Hesaplama#################################
        frame_counter += 1
        elapsed_time = time.time() - start_time
        if elapsed_time >= 1:  # Her 1 saniyede bir güncelle
            fps = frame_counter / elapsed_time
            frame_counter = 0
            start_time = time.time()
        # FPS yazısını ekrana çiz
        #cv.putText(
            segments,
            f"FPS: {fps:.1f}",
            (10, 30),  # Sol üst köşe
            cv.FONT_HERSHEY_SIMPLEX,
            0.7,
            (0, 255, 0),  # Yeşil renk
            2
        #)
        ##################################### FPS Hesaplama#################################
        # Saat dilimini belirle ve güncel zamanı al
        tz = pytz.timezone(city.timezone)
        current_tztime = datetime.now(tz)

        # Gün doğumu ve batımı saatlerini hesapla
        s = sun(city.observer, date=current_tztime.date(), tzinfo=tz)

        sunrise = s["sunrise"]  # Güneşin doğuş saati
        sunset = s["sunset"]  # Güneşin batış saati

        sunset_plus_30 = sunset + timedelta(minutes=20)  # Gün batımından 30 dakika sonrası
        sunrise_plus_30 = sunrise + timedelta(minutes=10)  # Gün doğumundan 30 dakika sonrası

        # aksam = current_tztime > sunrise and current_tztime < sunset or current_tztime > sunrise and current_tztime < sunset

        #benim kodum
        # aksam = current_tztime < sunrise_plus_30 and current_tztime < sunset_plus_30 or current_tztime > sunrise_plus_30 and current_tztime > sunset_plus_30
        aksam = current_tztime < sunrise_plus_30 or current_tztime > sunset_plus_30

        # Eğer saat gün doğumundan ve gün batımından büyükse ve gün doğumundan küçük gün batımından büyüske.
        if aksam:
            # OpenCV görüntüsünü Pillow formatına dönüştür
            pil_image = Image.fromarray(cv.cvtColor(segments, cv.COLOR_BGR2RGB))
            draw = ImageDraw.Draw(pil_image)

            # Yazı pozisyonu ve yazı
            text_position = (coordinate[0] + 10, coordinate[1])
            draw.text(text_position, "Akşam olduğu için tespit yapılamıyor.", font=font,
                      fill=(255, 255, 0))  # Sarı renk

            # Pillow görüntüsünü tekrar OpenCV formatına dönüştür
            segments = cv.cvtColor(np.array(pil_image), cv.COLOR_RGB2BGR)
            # print("Gece modu aktif, gamma açılıyor...")
            image = adjust_gamma(image, gamma=3.0)  # Gece için daha parlak hale getir

        # ROI 1'nin durumunu kontrol et ve yazı yaz
        if aksam:
            # Akşam durumu varsa ekrana yazma, sadece MQTT mesajı gönder
            result = mqtt_client.publish(MQTT_TOPIC_SLOT1, "Akşam tespit edilmiyor.")
            if result.rc == 0:
                pass  # print("MQTT Mesaj yayınlandı: Akşam oldu")
        else:
            # Akşam değilse, ROI durumunu kontrol et ve yaz
            current_time = time.localtime()
            if specific_pixel_occupied_roi1 != roi1_prev_status:
                roi1_stable_count += 1
            else:
                roi1_stable_count = 0
            if specific_pixel_occupied_roi1:
                put_text_with_border(segments, "DOLU", roi1_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "DOLU", roi1_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                apply_transparent_color(segments, roi1_points, (0, 0, 255), 0.10)  # BGR: kırmızı

                # Durum değiştiğinde saati kaydet
                if roi1_prev_status != specific_pixel_occupied_roi1:
                    roi1_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                # Park etme saatini göster
                if roi1_status_hour:
                    time_position = (roi1_bottom_left[0], roi1_bottom_left[1] + 10)
                    put_text_with_border(segments, f"Park: {roi1_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 0, 255), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Park: {roi1_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)

                if roi1_stable_count >= 3:
                    if specific_pixel_occupied_roi1:
                        # Durum değiştiğinde saati kaydet (sadece ilk kez güncellenecek)
                        roi1_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT1, "Slot 1 dolu")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 1 dolu")
                    # Güncelleme yapıldıktan sonra sayacı sıfırlayın
                    roi1_prev_status = specific_pixel_occupied_roi1
                    roi1_stable_count = 0
            else:
                put_text_with_border(segments, "BOS", roi1_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "BOS", roi1_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                apply_transparent_color(segments, roi1_points, (0, 255, 0), 0.25)  # BGR: yeşil
                if roi1_prev_status != specific_pixel_occupied_roi1:
                    roi1_status_time = current_time

                # Durum değiştiğinde saati kaydet
                if roi1_prev_status != specific_pixel_occupied_roi1:
                    roi1_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                # Boşalma saatini göster
                if roi1_status_hour:
                    time_position = (roi1_bottom_left[0], roi1_bottom_left[1] + 10)
                    put_text_with_border(segments, f"Park: {roi1_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 255, 0), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Bos: {roi1_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                if roi1_stable_count >= 3:
                    if not specific_pixel_occupied_roi1:
                        roi1_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT1, "Slot 1 boş")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 1 boş")

                    # Güncelleme yapıldıktan sonra sayacı sıfırlayın
                    roi1_prev_status = specific_pixel_occupied_roi1
                    roi1_stable_count = 0

        # roi 1'nin önceki durumunu güncelle
        #roi1_prev_status = specific_pixel_occupied_roi1

        # ROI 2'nin durumunu kontrol et ve yazı yaz
        if aksam:
            # Akşam durumu varsa ekrana yazma, sadece MQTT mesajı gönder
            result = mqtt_client.publish(MQTT_TOPIC_SLOT2, "Akşam tespit edilmiyor.")
            if result.rc == 0:
                pass  # print("MQTT Mesaj yayınlandı: Akşam oldu")
        else:
            # Akşam değilse, ROI durumunu kontrol et ve yaz
            current_time = time.localtime()
            if specific_pixel_occupied_roi2:
                put_text_with_border(segments, "DOLU", roi2_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255),
                                     thickness=1, border_thickness=2)
                # put_text_with_border(segments, "DOLU", roi1_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), thickness=1, border_thickness=2)
                # cv.putText(segments, "DOLU", roi2_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                apply_transparent_color(segments, roi2_points, (0, 0, 255), 0.10)  # BGR: kırmızı
                # Durum değiştiğinde saati kaydet
                if roi2_prev_status != specific_pixel_occupied_roi2:
                    roi2_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"

                # Park etme saatini göster
                if roi2_status_hour:
                    time_position = (roi2_bottom_left[0], roi2_bottom_left[1] + 20)
                    put_text_with_border(segments, f"Park: {roi2_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 0, 255), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Park: {roi2_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)

                if specific_pixel_occupied_roi2 != roi2_prev_status:
                    if specific_pixel_occupied_roi2:
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT2, "Slot 2 dolu")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 2 dolu")
            else:
                put_text_with_border(segments, "BOS", roi2_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "BOS", roi2_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                apply_transparent_color(segments, roi2_points, (0, 255, 0), 0.15)  # BGR: yeşil
                # Durum değiştiğinde saati kaydet
                if roi2_prev_status != specific_pixel_occupied_roi2:
                    roi2_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"

                # Boşalma saatini göster
                if roi2_status_hour:
                    time_position = (roi2_bottom_left[0], roi2_bottom_left[1] + 20)
                    put_text_with_border(segments, f"Park: {roi2_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 255, 0), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Bos: {roi2_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                if specific_pixel_occupied_roi2 != roi2_prev_status:
                    result = mqtt_client.publish(MQTT_TOPIC_SLOT2, "Slot 2 boş")
                    if result.rc == 0:
                        print("MQTT Mesaj yayınlandı: Slot 2 boş")

        # ROI 2'nin önceki durumunu güncelle
        roi2_prev_status = specific_pixel_occupied_roi2

        # ROI 3'nin durumunu kontrol et ve yazı yaz
        if aksam:
            # Akşam durumu varsa ekrana yazma, sadece MQTT mesajı gönder
            result = mqtt_client.publish(MQTT_TOPIC_SLOT3, "Akşam tespit edilmiyor.")
            if result.rc == 0:
                pass  # print("MQTT Mesaj yayınlandı: Akşam oldu")
        else:
            # Akşam değilse, ROI durumunu kontrol et ve yaz
            current_time = time.localtime()
            if specific_pixel_occupied_roi3 != roi3_prev_status:
                roi3_stable_count += 1
            else:
                roi3_stable_count = 0
            if specific_pixel_occupied_roi3:
                put_text_with_border(segments, "DOLU", roi3_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "DOLU", roi3_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                apply_transparent_color(segments, roi3_points, (0, 0, 255), 0.10)  # BGR: kırmızı

                # Durum değiştiğinde saati kaydet
                if roi3_prev_status != specific_pixel_occupied_roi3:
                    roi3_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                # Park etme saatini göster
                if roi3_status_hour:
                    time_position = (roi3_bottom_left[0], roi3_bottom_left[1] + 10)
                    put_text_with_border(segments, f"Park: {roi3_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 0, 255), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Park: {roi3_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)

                if roi3_stable_count >= 13:
                    if specific_pixel_occupied_roi3:
                        # Durum değiştiğinde saati kaydet (sadece ilk kez güncellenecek)
                        roi3_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT3, "Slot 3 dolu")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 3 dolu")
                        print(f"--------dolu------ROI3 Stabil Sayac: {roi3_stable_count}----------")
                    # Güncelleme yapıldıktan sonra sayacı sıfırlayın
                    roi3_prev_status = specific_pixel_occupied_roi3
                    roi3_stable_count = 0
            else:
                put_text_with_border(segments, "BOS", roi3_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "BOS", roi3_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                apply_transparent_color(segments, roi3_points, (0, 255, 0), 0.25)  # BGR: yeşil
                if roi3_prev_status != specific_pixel_occupied_roi3:
                    roi3_status_time = current_time

                # Durum değiştiğinde saati kaydet
                if roi3_prev_status != specific_pixel_occupied_roi3:
                    roi3_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                # Boşalma saatini göster
                if roi3_status_hour:
                    time_position = (roi3_bottom_left[0], roi3_bottom_left[1] + 10)
                    put_text_with_border(segments, f"Park: {roi3_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 255, 0), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Bos: {roi3_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                if roi3_stable_count >= 13:
                    if not specific_pixel_occupied_roi3:
                        roi3_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT3, "Slot 3 boş")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 3 boş")
                    print(f"---------bos-----ROI3 Stabil Sayac: {roi3_stable_count}----------")
                    # Güncelleme yapıldıktan sonra sayacı sıfırlayın
                    roi3_prev_status = specific_pixel_occupied_roi3
                    roi3_stable_count = 0

        # ROI 3'nin önceki durumunu güncelle
        #roi3_prev_status = specific_pixel_occupied_roi3

        # ROI 4'nin durumunu kontrol et ve yazı yaz
        if aksam:
            # Akşam durumu varsa ekrana yazma, sadece MQTT mesajı gönder
            result = mqtt_client.publish(MQTT_TOPIC_SLOT4, "Akşam tespit edilmiyor.")
            if result.rc == 0:
                pass  # print("MQTT Mesaj yayınlandı: Akşam oldu")
        else:
            # Akşam değilse, ROI durumunu kontrol et ve yaz
            current_time = time.localtime()
            if specific_pixel_occupied_roi4 != roi4_prev_status:
                roi4_stable_count += 1
            else:
                roi4_stable_count = 0
            if specific_pixel_occupied_roi4:
                put_text_with_border(segments, "DOLU", roi4_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "DOLU", roi4_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                apply_transparent_color(segments, roi4_points, (0, 0, 255), 0.10)  # BGR: kırmızı

                # Durum değiştiğinde saati kaydet
                if roi4_prev_status != specific_pixel_occupied_roi4:
                    roi4_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                # Park etme saatini göster
                if roi4_status_hour:
                    time_position = (roi4_bottom_left[0], roi4_bottom_left[1] + 20)
                    put_text_with_border(segments, f"Park: {roi4_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 0, 255), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Park: {roi4_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)

                if roi4_stable_count >= 130:
                    if specific_pixel_occupied_roi4:
                        # Durum değiştiğinde saati kaydet (sadece ilk kez güncellenecek)
                        roi4_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT4, "Slot 4 dolu")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 4 dolu")
                        print(f"--------dolu------ROI4 Stabil Sayac: {roi4_stable_count}----------")
                    # Güncelleme yapıldıktan sonra sayacı sıfırlayın
                    roi4_prev_status = specific_pixel_occupied_roi4
                    roi4_stable_count = 0
            else:
                put_text_with_border(segments, "BOS", roi4_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "BOS", roi4_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                apply_transparent_color(segments, roi4_points, (0, 255, 0), 0.25)  # BGR: yeşil
                if roi4_prev_status != specific_pixel_occupied_roi4:
                    roi4_status_time = current_time

                # Durum değiştiğinde saati kaydet
                if roi4_prev_status != specific_pixel_occupied_roi4:
                    roi4_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                # Boşalma saatini göster
                if roi4_status_hour:
                    time_position = (roi4_bottom_left[0], roi4_bottom_left[1] + 20)
                    put_text_with_border(segments, f"Park: {roi4_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 255, 0), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Bos: {roi4_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                if roi4_stable_count >= 130:
                    if not specific_pixel_occupied_roi4:
                        roi4_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT4, "Slot 4 boş")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 4 boş")
                    print(f"---------bos-----ROI4 Stabil Sayac: {roi4_stable_count}----------")
                    # Güncelleme yapıldıktan sonra sayacı sıfırlayın
                    roi4_prev_status = specific_pixel_occupied_roi4
                    roi4_stable_count = 0

        # ROI 4'nin önceki durumunu güncelle
        #roi4_prev_status = specific_pixel_occupied_roi4

        # roi 5'nin durumunu kontrol et ve yazı yaz
        if aksam:
            # Akşam durumu varsa ekrana yazma, sadece MQTT mesajı gönder
            result = mqtt_client.publish(MQTT_TOPIC_SLOT5, "Akşam oldu")
            if result.rc == 0:
                pass  # print("MQTT Mesaj yayınlandı: Akşam oldu")
        else:
            current_time = time.localtime()
            # Akşam değilse, ROI durumunu kontrol et ve yaz
            if specific_pixel_occupied_roi5:
                put_text_with_border(segments, "DOLU", roi5_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "DOLU", roi5_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                apply_transparent_color(segments, roi5_points, (0, 0, 255), 0.10)  # BGR: kırmızı
                # Durum değiştiğinde saati kaydet
                if roi5_prev_status != specific_pixel_occupied_roi5:
                    roi5_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"

                # Park etme saatini göster
                if roi5_status_hour:
                    time_position = (roi5_bottom_left[0], roi5_bottom_left[1] + 10)
                    put_text_with_border(segments, f"Park: {roi5_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 0, 255), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Park: {roi5_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                if specific_pixel_occupied_roi5 != roi5_prev_status:
                    if specific_pixel_occupied_roi5:
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT5, "Slot 5 dolu")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 5 dolu")
            else:
                put_text_with_border(segments, "BOS", roi5_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "BOS", roi5_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                apply_transparent_color(segments, roi5_points, (0, 255, 0), 0.15)  # BGR: yeşil
                # Durum değiştiğinde saati kaydet
                if roi5_prev_status != specific_pixel_occupied_roi5:
                    roi5_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"

                # Boşalma saatini göster
                if roi5_status_hour:
                    time_position = (roi5_bottom_left[0], roi5_bottom_left[1] + 10)
                    put_text_with_border(segments, f"Park: {roi5_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 255, 0), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Bos: {roi5_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                if specific_pixel_occupied_roi5 != roi5_prev_status:
                    result = mqtt_client.publish(MQTT_TOPIC_SLOT5, "Slot 5 boş")
                    if result.rc == 0:
                        print("MQTT Mesaj yayınlandı: Slot 5 boş")

        # roi 5'nin önceki durumunu güncelle
        roi5_prev_status = specific_pixel_occupied_roi5

        # roi 6'nin durumunu kontrol et ve yazı yaz
        if aksam:
            # Akşam durumu varsa ekrana yazma, sadece MQTT mesajı gönder
            result = mqtt_client.publish(MQTT_TOPIC_SLOT6, "Akşam oldu")
            if result.rc == 0:
                pass  # print("MQTT Mesaj yayınlandı: Akşam oldu")
        else:
            # Akşam değilse, ROI durumunu kontrol et ve yaz
            current_time = time.localtime()
            if specific_pixel_occupied_roi6:
                # Yazı eklemek için
                put_text_with_border(segments, "DOLU", roi6_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255),
                                     thickness=1, border_thickness=2)

                apply_transparent_color(segments, roi6_points, (0, 0, 255), 0.10)  # BGR: kırmızı
                # Durum değiştiğinde saati kaydet
                if roi6_prev_status != specific_pixel_occupied_roi6:
                    roi6_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"

                # Park etme saatini göster
                if roi6_status_hour:
                    time_position = (roi6_bottom_left[0], roi6_bottom_left[1] + 20)
                    # Yazı eklemek için
                    put_text_with_border(segments, f"Park: {roi6_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 0, 255), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Park: {roi6_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 0, 255), 1)
                if specific_pixel_occupied_roi6 != roi6_prev_status:
                    if specific_pixel_occupied_roi6:
                        result = mqtt_client.publish(MQTT_TOPIC_SLOT6, "Slot 6 dolu")
                        if result.rc == 0:
                            print("MQTT Mesaj yayınlandı: Slot 6 dolu")
            else:
                put_text_with_border(segments, "BOS", roi6_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0),
                                     thickness=1, border_thickness=2)
                # cv.putText(segments, "BOS", roi6_bottom_left, cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                apply_transparent_color(segments, roi6_points, (0, 255, 0), 0.15)  # BGR: yeşil
                # Durum değiştiğinde saati kaydet
                if roi6_prev_status != specific_pixel_occupied_roi6:
                    roi6_status_hour = f"{current_time.tm_hour:02d}:{current_time.tm_min:02d}"

                # Boşalma saatini göster
                if roi6_status_hour:
                    time_position = (roi6_bottom_left[0], roi6_bottom_left[1] + 20)
                    put_text_with_border(segments, f"Park: {roi6_status_hour}", time_position, cv.FONT_HERSHEY_SIMPLEX,
                                         0.3, (0, 255, 0), thickness=1, border_thickness=2)
                    # cv.putText(segments, f"Bos: {roi6_status_hour}", time_position,
                    # cv.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
                if specific_pixel_occupied_roi6 != roi6_prev_status:
                    result = mqtt_client.publish(MQTT_TOPIC_SLOT6, "Slot 6 boş")
                    if result.rc == 0:
                        print("MQTT Mesaj yayınlandı: Slot 6 boş")

        # roi 6'nin önceki durumunu güncelle
        roi6_prev_status = specific_pixel_occupied_roi6

        # ROI durumlarını kontrol et
        if specific_pixel_occupied_roi1:
            occupied_count += 1
        else:
            empty_count += 1
            empty_slots.append(1)

        if specific_pixel_occupied_roi2:
            occupied_count += 1
        else:
            empty_count += 1
            empty_slots.append(2)

        if specific_pixel_occupied_roi3:
            occupied_count += 1
        else:
            empty_count += 1
            empty_slots.append(3)

        if specific_pixel_occupied_roi4:
            occupied_count += 1
        else:
            empty_count += 1
            empty_slots.append(4)

        if specific_pixel_occupied_roi5:
            occupied_count += 1
        else:
            empty_count += 1
            empty_slots.append(5)

        if specific_pixel_occupied_roi6:
            occupied_count += 1
        else:
            empty_count += 1
            empty_slots.append(6)

        # Durum değişmişse güncelle ve MQTT ile yayınla
        if (occupied_count != prev_occupied_count or
                empty_count != prev_empty_count or
                empty_slots != prev_empty_slots):

            if aksam:
                print("Akşam tespit yapılamıyor")
                mqtt_client.publish("parking/status/empty_slots", "Akşam tespit yapılamıyor", retain=True)
                mqtt_client.publish("parking/status/occupied", "Akşam tespit yapılamıyor", retain=True)
                mqtt_client.publish("parking/status/empty", "Akşam tespit yapılamıyor", retain=True)
            else:
                print(f"Dolu park yerleri: {occupied_count}, Boş park yerleri: {empty_count}")
                if empty_slots:
                    print(f"Boş park yerleri: {', '.join(map(str, empty_slots))}")
                    mqtt_client.publish("parking/status/empty_slots", ','.join(map(str, empty_slots)), retain=True)
                else:
                    print("Boş park yeri yok")
                    mqtt_client.publish("parking/status/empty_slots", "none", retain=True)

                mqtt_client.publish("parking/status/occupied", str(occupied_count), retain=True)
                mqtt_client.publish("parking/status/empty", str(empty_count), retain=True)

            prev_occupied_count = occupied_count
            prev_empty_count = empty_count
            prev_empty_slots = empty_slots

            # Görüntüyü ekranda göster
        cv.imshow('Otopark Kontrol', segments)

        # Çıkış için 'q' tuşuna basılması gerekiyor
        key = cv.waitKey(1)
        if key & 0xFF == ord('q'):
            print('Çıkış işlemi başlatıldı.')
            break

finally:
    cap.release()
    cv.destroyAllWindows()
